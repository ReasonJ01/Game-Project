-- For save and load functions
require "modules.save_load"

--Create ignore property, set to false
go.property("ignore_collisions", false)

function increase_score()
	score = score + 1
	print(score)
end

function init(self)
	--Initialise variables
	player_data = load("player_data",nil, true)
	strafe_speed = player_data["strafe_speed"]
	ram_durability = player_data["ram_durability"]
	multiplier = player_data["score_mult"]
	
	msg.post(".", "acquire_input_focus")
	
	self.base_speed= 100
	self.speed = 0
	score = 1
	
	-- Used to define movement bounds in update
	width, height = window.get_size()
	
	--Start particlefx
	particlefx.play("/player#water")

	timer.delay(15, true, increase_score)
end

function final(self)
	msg.post("controller:/controller_object#game_proxy", "set_time_step", {factor = 1, mode = 1})
end

function update(self, dt)
	-- Get position and modify based on input, set new position
	pos = go.get_position()
	--dt is time delta between frames
	pos.x = pos.x +  self.speed * dt
	if pos.x >= width then
		pos.x = width
	elseif pos.x <= 0 then
		pos.x = 0
	end
	
	go.set_position(pos)
	self.speed = 0
	msg.post("/gui#game", "increase_score", {value = score * multiplier})
end

function collision(self)
	-- "Pauses" the game
	msg.post("controller:/controller_object#game_proxy", "set_time_step", {factor = 0, mode = 1})
	-- stop score from increasing
	multiplier = 0
	score = 1
	-- Set player sprite back to ship
	sprite.play_flipbook("/player#sprite", "ship")
	-- move player to middle of screen
	pos = go.get_position()
	pos.x = width/2
	go.set_position(pos)
	-- Show "play" button
	msg.post("/gui#game", "show_play")
end

function endInvincibility(self)
	--Collisions no longer ignored, end glowing effect, set alpha to default
	self.ignore_collisions = false
	go.cancel_animations("player#sprite", "tint.w")
	go.set("player#sprite", "tint.w", 1)
end

function on_message(self, message_id, message, sender)
	-- collision_response is sent after any collision, only acknowledge if not ignoring collisions
	if message_id == hash("collision_response") and not self.ignore_collisions then
		-- If collision is with tip of ship and there is still ram durability then 
		if sender == msg.url(nil, "player", "ship_tip_collision") and ram_durability > 0 then
			-- Ignore collisions
			self.ignore_collisions = true
			-- Glowing effect
			go.animate("/player#sprite", "tint.w", go.PLAYBACK_LOOP_PINGPONG, 2, go.EASING_INSINE, 1.5)
			-- Reduce ram_durability
			ram_durability = ram_durability - 1
			-- Just long enough for the first collision
			timer.delay(0.4, false, endInvincibility)
		else
			--Ignore collisions
			self.ignore_collisions = true
			-- Message obstacle factory to delete all obstacles
			particlefx.stop("/player#water")
			-- Play explosion animation then call collision()
			sprite.play_flipbook("/player#sprite", "explosion", collision)
		end
		
	elseif message_id == hash("unpause") then
		go.animate("/player#sprite", "tint.w", go.PLAYBACK_LOOP_PINGPONG, 2, go.EASING_INSINE, 1.5)
		-- Restart particle fx
		particlefx.play("/player#water")
		-- Unpause the game
		msg.post("controller:/controller_object#game_proxy", "set_time_step", {factor = 1, mode = 1})
		-- Resume score increase
		multiplier = player_data["score_mult"]
		-- begin invincibility timer
		timer.delay(5, false, endInvincibility)
	end
end

function on_input(self, action_id, action)
	if action_id == hash("left") then
		self.speed = -(self.base_speed + strafe_speed)

	elseif action_id == hash("right") then
		self.speed = self.base_speed + strafe_speed
	end
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end
