-- For save and load functions
require "modules.save_load"

--Create ignore property, set to false
go.property("ignore_collisions", false)

--Increaes the score earned over time. Called on line 33 
function increase_base_score()
	base_score = base_score + 1
	print(base_score)
end

--Function adapted from  https://defold.com/examples/physics/raycast/
local function draw_line(from, to, color)
	msg.post("@render:", "draw_line", { start_point = from, end_point = to, color = color })
end

function init(self)
	--Initialise variables
	player_data = load("player_data",nil, true)
	strafe_speed = player_data["strafe_speed"]
	ram_durability = player_data["ram_durability"]
	multiplier = player_data["score_mult"]
	print("speed", strafe_speed)
	msg.post(".", "acquire_input_focus")
	msg.post("/gui#game", "set_ram", { durability = ram_durability })
	
	self.base_speed= 50
	self.speed = 0
	
	-- Used to define movement bounds in update
	width, height = window.get_size()

	left = 0
	right = 0
	
	--Start particlefx
	particlefx.play("/player#water")

	
	base_score = 1
	--Every 10 seconds the score earned per update increaes by 1
	timer.delay(7, true, increase_base_score)

	--sound.pause("/obstacle_gen#sound", true)
end

function final(self)
	msg.post("controller:/controller_object#game_proxy", "set_time_step", {factor = 1, mode = 1})
	sound_played = false
	music = false
	raycasting = false
end

function update(self, dt)
	-- Get position and modify based on input, set new position
	pos = go.get_position()

	if raycasting then
		for i=pos.x - 350, pos.x + 350, 15 do

			y = (i-pos.x)^2
			y = 122500 - (y)
			y = math.sqrt(y)
			y = pos.y + y	

			to = vmath.vector3(i, y, pos.z)
			result = physics.raycast(vmath.vector3(pos.x, pos.y -20, pos.z), to, { hash("enemy"), hash("bounds"), hash("map"), hash("hostile"), hash("power_up") }, false)
			if result then
				draw_line(vmath.vector3(pos.x, pos.y -20, pos.z), result.position,  vmath.vector4(1,0,1,1))
				-- Loop for adding bias
				if result.group == hash("hostile") then
					result.fraction = result.fraction / 5

				elseif result.group == hash("enemy") then
					result.fraction = result.fraction / 2
				elseif result.group == hash("power_up") then
					result.fraction = -result.fraction / 4
				end

				if result.position.x <= pos.x then
					if result.position.x >= pos.x - 60 then
						result.fraction = result.fraction / 2
					end
					left = left + (1/result.fraction)
				else
					if result.position.x <= pos.x + 60 then
						result.fraction = result.fraction / 2
					end
					right = right + (1/result.fraction)
				end
			else
				--draw_line(vmath.vector3(pos.x, pos.y -20, pos.z), to, vmath.vector4(1,0,0,1))
			end
			label.set_text("/labels#left", left)
			label.set_text("/labels#right", right)
		end
		
		if (left == 0) and (right > 0) then
			--self.speed = (self.base_speed + strafe_speed) * (left/20)
		elseif (right == 0) and (left > 0) then
			--self.speed = -(self.base_speed + strafe_speed) * (right/20)
		end

		if left >= right then
			--self.speed = math.min((self.base_speed + strafe_speed) * (left/60), (self.base_speed + strafe_speed))
			self.speed = (self.base_speed + strafe_speed) * (left/40)
		elseif left < right then
			--self.speed = math.max(-(self.base_speed + strafe_speed) * (right/60), -(self.base_speed + strafe_speed))
			self.speed = -(self.base_speed + strafe_speed) * (right/40)
		elseif left > 0 then
			self.speed = -100
		else
			self.speed = 0
		end

	end

	
	--dt is time delta between frames
	pos.x = pos.x +  self.speed * dt
	if pos.x >= width then
		pos.x = width
	elseif pos.x <= 0 then
		pos.x = 0
	end
	
	go.set_position(pos)
	self.speed = 0
	left = 0
	right = 0
	
	--Update the score shown in the gui.
	msg.post("/gui#game", "increase_score", {value = base_score * multiplier})
end

function collision(self)

	left = 0
	right = 0
	self.speed = 0
	if music then
		sound.pause("/obstacle_gen#sound", true)
		music = "play"
	end
	-- "Pauses" the game
	
	msg.post("controller:/controller_object#game_proxy", "set_time_step", {factor = 0, mode = 1})
	paused = true
	-- stop score from increasing
	base_score = 0
	-- Set player sprite back to ship
	sprite.play_flipbook("/player#sprite", "ship")
	-- move player to middle of screen
	pos = go.get_position()
	pos.x = width/2
	go.set_position(pos)
	-- Show "play" button
	msg.post("/gui#game", "show_play")
end

function endInvincibility(self)
	--Collisions no longer ignored, end glowing effect, set alpha to default
	self.ignore_collisions = false
	go.cancel_animations("player#sprite", "tint.w")
	go.set("player#sprite", "tint.w", 1)
end

function on_message(self, message_id, message, sender)
	-- collision_response is sent after any collision, only acknowledge if not ignoring collisions and it is not a powerup
	if message_id == hash("collision_response") and not self.ignore_collisions and message.other_group ~= hash("power_up") then
		-- If collision is with tip of ship and there is still ram durability then 
		if sender == msg.url(nil, "player", "ship_tip_collision") and ram_durability > 0 then
			-- Ignore collisions
			self.ignore_collisions = true
			-- Glowing effect
			go.animate("/player#sprite", "tint.w", go.PLAYBACK_LOOP_PINGPONG, 2, go.EASING_INSINE, 1.5)
			-- Reduce ram_durability
			ram_durability = ram_durability - 1
			-- Update gui
			msg.post("/gui#game", "set_ram", { durability = ram_durability })
			-- Just long enough for the first collision
			timer.delay(0.4, false, endInvincibility)
		else
			--Ignore collisions
			self.ignore_collisions = true
			particlefx.stop("/player#water")
			-- Play explosion animation then call collision()
			sprite.play_flipbook("/player#sprite", "explosion", collision)
		end
		
	elseif message_id == hash("unpause") then
		if music == "play" then
			sound.pause("/obstacle_gen#sound", false)
		end
		go.animate("/player#sprite", "tint.w", go.PLAYBACK_LOOP_PINGPONG, 2, go.EASING_INSINE, 1.5)
		-- Restart particle fx
		particlefx.play("/player#water")
		-- Unpause the game
		msg.post("controller:/controller_object#game_proxy", "set_time_step", {factor = 1, mode = 1})
		paused = false
		-- Resume score increase
		base_score = 1
		-- begin invincibility timer
		timer.delay(5, false, endInvincibility)
	end
end

function on_input(self, action_id, action)
	if action_id == hash("left") then
		self.speed = -(self.base_speed + strafe_speed)

	elseif action_id == hash("right") then
		self.speed = self.base_speed + strafe_speed

	elseif action_id == hash("raycast") and action.released then
		if raycasting then
			raycasting = false
			label.set_text("/labels#left", "")
			label.set_text("/labels#right", "")
		else
			raycasting = true
		end
	elseif action_id == hash("sound") and action.released and not paused then
		if music then
			sound.pause("/obstacle_gen#sound", true)
			music = false
			muliplier = multiplier / 2
			go.cancel_animations("player#sprite", "tint")
			go.set("player#sprite", "tint",vmath.vector4(1, 1, 1, 1))
			
		elseif sound_played then
			sound.pause("/obstacle_gen#sound", false)
			music = true
			muliplier = multiplier * 2
			go.animate("player#sprite", "tint", go.PLAYBACK_LOOP_PINGPONG, vmath.vector4(0.8, 0, 1, 1.2), go.EASING_INSINE, 1, 1)
			
		else
			sound.play("/obstacle_gen#sound")
			sound_played = true
			music = true
			muliplier = multiplier * 2
			go.animate("player#sprite", "tint", go.PLAYBACK_LOOP_PINGPONG, vmath.vector4(0.8, 0, 1, 1.2), go.EASING_INSINE, 1, 1)
		end
	end
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end
